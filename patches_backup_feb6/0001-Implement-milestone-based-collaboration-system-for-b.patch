From dff50703303c315f9cd69649ac917ac713eb37fe Mon Sep 17 00:00:00 2001
From: HundredCentury100 <hundredtechnologies2023@gmail.com>
Date: Fri, 6 Feb 2026 14:20:26 +0200
Subject: [PATCH] Implement milestone-based collaboration system for briefs and
 campaigns
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Backend Changes:
- Added 3 new endpoints for milestone deliverable management:
  * POST /collaborations/:id/milestones/:mid/deliverables - Submit deliverable to milestone
  * POST /collaborations/:id/milestones/:mid/deliverables/:did/approve - Approve deliverable
  * POST /collaborations/:id/milestones/:mid/deliverables/:did/request-revision - Request revision
- Added release_milestone_escrow() function for per-milestone payment release
- Milestone completion triggers 30-day escrow countdown
- Auto-completes collaboration when all milestones are completed
- Updates milestone status from pending -> in_progress when first deliverable submitted

Payment Service:
- Added release_milestone_escrow() to handle per-milestone escrow release
- Creates WalletTransaction with 30-day clearance period
- Calculates platform fee (15%) and net amount for creator

Frontend API:
- Added submitMilestoneDeliverable() method
- Added approveMilestoneDeliverable() method
- Added requestMilestoneRevision() method
- Separated milestone deliverable APIs from package deliverable APIs

How It Works:
1. Brand accepts brief proposal -> Collaboration created with milestones
2. Creator submits deliverables to specific milestone
3. Brand approves/rejects deliverables per milestone
4. When all deliverables in milestone approved -> Milestone completes -> Escrow released (30 days)
5. When all milestones complete -> Collaboration marked as completed

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 backend/app/routes/collaborations.py    | 436 +++++++++++++++++++++++-
 backend/app/services/payment_service.py |  73 ++++
 frontend/src/services/api.js            |  10 +-
 3 files changed, 516 insertions(+), 3 deletions(-)

diff --git a/backend/app/routes/collaborations.py b/backend/app/routes/collaborations.py
index 3578691..6fae55e 100644
--- a/backend/app/routes/collaborations.py
+++ b/backend/app/routes/collaborations.py
@@ -1,8 +1,8 @@
 from flask import Blueprint, request, jsonify
 from flask_jwt_extended import jwt_required, get_jwt_identity
-from datetime import datetime
+from datetime import datetime, timedelta
 from app import db, socketio
-from app.models import Collaboration, BrandProfile, CreatorProfile, User
+from app.models import Collaboration, BrandProfile, CreatorProfile, User, CollaborationMilestone, MilestoneDeliverable
 from app.utils.notifications import notify_collaboration_status, notify_collaboration_update
 
 bp = Blueprint('collaborations', __name__)
@@ -1099,3 +1099,435 @@ def cancel_collaboration(collab_id):
     except Exception as e:
         db.session.rollback()
         return jsonify({'error': str(e)}), 500
+
+
+# ============================================================================
+# MILESTONE DELIVERABLE ENDPOINTS (for Brief/Campaign Collaborations)
+# ============================================================================
+
+@bp.route('/<int:collab_id>/milestones/<int:milestone_id>/deliverables', methods=['POST'])
+@jwt_required()
+def submit_milestone_deliverable(collab_id, milestone_id):
+    """Submit deliverable to a specific milestone (creator only)"""
+    try:
+        user_id = int(get_jwt_identity())
+        creator = CreatorProfile.query.filter_by(user_id=user_id).first()
+
+        if not creator:
+            return jsonify({'error': 'Creator profile not found'}), 404
+
+        collaboration = Collaboration.query.get(collab_id)
+        if not collaboration:
+            return jsonify({'error': 'Collaboration not found'}), 404
+
+        if collaboration.creator_id != creator.id:
+            return jsonify({'error': 'Unauthorized'}), 403
+
+        milestone = CollaborationMilestone.query.get(milestone_id)
+        if not milestone or milestone.collaboration_id != collab_id:
+            return jsonify({'error': 'Milestone not found'}), 404
+
+        data = request.get_json()
+
+        # Validate required fields
+        if 'title' not in data or 'url' not in data:
+            return jsonify({'error': 'Title and URL are required'}), 400
+
+        # Create deliverable
+        deliverable = MilestoneDeliverable(
+            collaboration_milestone_id=milestone.id,
+            title=data['title'],
+            url=data['url'],
+            description=data.get('description', ''),
+            status='pending_review'
+        )
+        db.session.add(deliverable)
+        
+        # Update milestone status if it's pending
+        if milestone.status == 'pending':
+            milestone.status = 'in_progress'
+        
+        db.session.commit()
+
+        # Update collaboration
+        collaboration.last_update = f"Deliverable submitted for {milestone.title}"
+        collaboration.last_update_date = datetime.utcnow()
+        db.session.commit()
+
+        # Notify brand
+        brand_user = User.query.get(collaboration.brand.user_id)
+        if brand_user:
+            notify_collaboration_update(
+                user_id=brand_user.id,
+                collaboration_title=collaboration.title,
+                collaboration_id=collaboration.id,
+                update_message=f"New deliverable submitted for milestone: {milestone.title}"
+            )
+
+        return jsonify({
+            'message': 'Deliverable submitted successfully',
+            'deliverable': deliverable.to_dict(),
+            'milestone': milestone.to_dict(include_deliverables=True)
+        }), 201
+
+    except Exception as e:
+        db.session.rollback()
+        print(f"Error submitting milestone deliverable: {str(e)}")
+        import traceback
+        traceback.print_exc()
+        return jsonify({'error': str(e)}), 500
+
+
+@bp.route('/<int:collab_id>/milestones/<int:milestone_id>/deliverables/<int:deliverable_id>/approve', methods=['POST'])
+@jwt_required()
+def approve_milestone_deliverable(collab_id, milestone_id, deliverable_id):
+    """Approve milestone deliverable (brand only)"""
+    try:
+        user_id = int(get_jwt_identity())
+        brand = BrandProfile.query.filter_by(user_id=user_id).first()
+
+        if not brand:
+            return jsonify({'error': 'Brand profile not found'}), 404
+
+        collaboration = Collaboration.query.get(collab_id)
+        if not collaboration:
+            return jsonify({'error': 'Collaboration not found'}), 404
+
+        if collaboration.brand_id != brand.id:
+            return jsonify({'error': 'Unauthorized'}), 403
+
+        milestone = CollaborationMilestone.query.get(milestone_id)
+        if not milestone or milestone.collaboration_id != collab_id:
+            return jsonify({'error': 'Milestone not found'}), 404
+
+        deliverable = MilestoneDeliverable.query.get(deliverable_id)
+        if not deliverable or deliverable.collaboration_milestone_id != milestone.id:
+            return jsonify({'error': 'Deliverable not found'}), 404
+
+        # Approve deliverable
+        deliverable.status = 'approved'
+        deliverable.approved_at = datetime.utcnow()
+        db.session.commit()
+
+        # Check if milestone is now complete (all deliverables approved)
+        if milestone.is_complete():
+            milestone.status = 'completed'
+            milestone.completed_at = datetime.utcnow()
+            milestone.approved_at = datetime.utcnow()
+
+            # Trigger escrow for this milestone
+            milestone.escrow_triggered_at = datetime.utcnow()
+            milestone.escrow_release_date = (datetime.utcnow() + timedelta(days=30)).date()
+
+            # Release escrow for this specific milestone
+            from app.services.payment_service import release_milestone_escrow
+            try:
+                transaction = release_milestone_escrow(milestone.id, platform_fee_percentage=15)
+                print(f"Milestone {milestone.id} escrow released. Transaction: {transaction.id}")
+            except Exception as e:
+                print(f"Warning: Failed to release milestone escrow: {str(e)}")
+
+            # Check if all milestones are complete
+            all_milestones = collaboration.milestones.all()
+            all_complete = all(m.status == 'completed' for m in all_milestones)
+            
+            if all_complete:
+                collaboration.status = 'completed'
+                collaboration.actual_completion_date = datetime.utcnow()
+                collaboration.progress_percentage = 100
+                
+                # Notify both parties
+                creator_user = User.query.get(collaboration.creator.user_id)
+                if creator_user:
+                    notify_collaboration_status(
+                        user_id=creator_user.id,
+                        status='completed',
+                        collaboration_title=collaboration.title,
+                        collaboration_id=collaboration.id,
+                        user_type='creator'
+                    )
+                
+                if brand.user_id:
+                    notify_collaboration_status(
+                        user_id=brand.user_id,
+                        status='completed',
+                        collaboration_title=collaboration.title,
+                        collaboration_id=collaboration.id,
+                        user_type='brand'
+                    )
+
+        db.session.commit()
+
+        # Notify creator about approval
+        creator_user = User.query.get(collaboration.creator.user_id)
+        if creator_user:
+            notify_collaboration_update(
+                user_id=creator_user.id,
+                collaboration_title=collaboration.title,
+                collaboration_id=collaboration.id,
+                update_message=f"Deliverable approved for {milestone.title}"
+            )
+
+        return jsonify({
+            'message': 'Deliverable approved successfully',
+            'deliverable': deliverable.to_dict(),
+            'milestone': milestone.to_dict(include_deliverables=True),
+            'collaboration': collaboration.to_dict(include_relations=True)
+        }), 200
+
+    except Exception as e:
+        db.session.rollback()
+        print(f"Error approving milestone deliverable: {str(e)}")
+        import traceback
+        traceback.print_exc()
+        return jsonify({'error': str(e)}), 500
+
+
+@bp.route('/<int:collab_id>/milestones/<int:milestone_id>/deliverables/<int:deliverable_id>/request-revision', methods=['POST
+
+
+# ============================================================================
+# MILESTONE DELIVERABLE ENDPOINTS (for Brief/Campaign Collaborations)
+# ============================================================================
+
+@bp.route('/<int:collab_id>/milestones/<int:milestone_id>/deliverables', methods=['POST'])
+@jwt_required()
+def submit_milestone_deliverable(collab_id, milestone_id):
+    """Submit deliverable to a specific milestone (creator only)"""
+    try:
+        user_id = int(get_jwt_identity())
+        creator = CreatorProfile.query.filter_by(user_id=user_id).first()
+
+        if not creator:
+            return jsonify({'error': 'Creator profile not found'}), 404
+
+        collaboration = Collaboration.query.get(collab_id)
+        if not collaboration:
+            return jsonify({'error': 'Collaboration not found'}), 404
+
+        if collaboration.creator_id != creator.id:
+            return jsonify({'error': 'Unauthorized'}), 403
+
+        milestone = CollaborationMilestone.query.get(milestone_id)
+        if not milestone or milestone.collaboration_id != collab_id:
+            return jsonify({'error': 'Milestone not found'}), 404
+
+        data = request.get_json()
+
+        # Validate required fields
+        if 'title' not in data or 'url' not in data:
+            return jsonify({'error': 'Title and URL are required'}), 400
+
+        # Create deliverable
+        deliverable = MilestoneDeliverable(
+            collaboration_milestone_id=milestone.id,
+            title=data['title'],
+            url=data['url'],
+            description=data.get('description', ''),
+            status='pending_review'
+        )
+        db.session.add(deliverable)
+
+        # Update milestone status if it's pending
+        if milestone.status == 'pending':
+            milestone.status = 'in_progress'
+
+        db.session.commit()
+
+        # Update collaboration
+        collaboration.last_update = f"Deliverable submitted for {milestone.title}"
+        collaboration.last_update_date = datetime.utcnow()
+        db.session.commit()
+
+        # Notify brand
+        brand_user = User.query.get(collaboration.brand.user_id)
+        if brand_user:
+            notify_collaboration_update(
+                user_id=brand_user.id,
+                collaboration_title=collaboration.title,
+                collaboration_id=collaboration.id,
+                update_message=f"New deliverable submitted for milestone: {milestone.title}"
+            )
+
+        return jsonify({
+            'message': 'Deliverable submitted successfully',
+            'deliverable': deliverable.to_dict(),
+            'milestone': milestone.to_dict(include_deliverables=True)
+        }), 201
+
+    except Exception as e:
+        db.session.rollback()
+        print(f"Error submitting milestone deliverable: {str(e)}")
+        import traceback
+        traceback.print_exc()
+        return jsonify({'error': str(e)}), 500
+
+
+@bp.route('/<int:collab_id>/milestones/<int:milestone_id>/deliverables/<int:deliverable_id>/approve', methods=['POST'])
+@jwt_required()
+def approve_milestone_deliverable(collab_id, milestone_id, deliverable_id):
+    """Approve milestone deliverable (brand only)"""
+    try:
+        user_id = int(get_jwt_identity())
+        brand = BrandProfile.query.filter_by(user_id=user_id).first()
+
+        if not brand:
+            return jsonify({'error': 'Brand profile not found'}), 404
+
+        collaboration = Collaboration.query.get(collab_id)
+        if not collaboration:
+            return jsonify({'error': 'Collaboration not found'}), 404
+
+        if collaboration.brand_id != brand.id:
+            return jsonify({'error': 'Unauthorized'}), 403
+
+        milestone = CollaborationMilestone.query.get(milestone_id)
+        if not milestone or milestone.collaboration_id != collab_id:
+            return jsonify({'error': 'Milestone not found'}), 404
+
+        deliverable = MilestoneDeliverable.query.get(deliverable_id)
+        if not deliverable or deliverable.collaboration_milestone_id != milestone.id:
+            return jsonify({'error': 'Deliverable not found'}), 404
+
+        # Approve deliverable
+        deliverable.status = 'approved'
+        deliverable.approved_at = datetime.utcnow()
+        db.session.commit()
+
+        # Check if milestone is now complete (all deliverables approved)
+        if milestone.is_complete():
+            milestone.status = 'completed'
+            milestone.completed_at = datetime.utcnow()
+            milestone.approved_at = datetime.utcnow()
+
+            # Trigger escrow for this milestone
+            milestone.escrow_triggered_at = datetime.utcnow()
+            milestone.escrow_release_date = (datetime.utcnow() + timedelta(days=30)).date()
+
+            # Release escrow for this specific milestone
+            from app.services.payment_service import release_milestone_escrow
+            try:
+                transaction = release_milestone_escrow(milestone.id, platform_fee_percentage=15)
+                print(f"Milestone {milestone.id} escrow released. Transaction: {transaction.id}")
+            except Exception as e:
+                print(f"Warning: Failed to release milestone escrow: {str(e)}")
+
+            # Check if all milestones are complete
+            all_milestones = collaboration.milestones.all()
+            all_complete = all(m.status == 'completed' for m in all_milestones)
+
+            if all_complete:
+                collaboration.status = 'completed'
+                collaboration.actual_completion_date = datetime.utcnow()
+                collaboration.progress_percentage = 100
+
+                # Notify both parties
+                creator_user = User.query.get(collaboration.creator.user_id)
+                if creator_user:
+                    notify_collaboration_status(
+                        user_id=creator_user.id,
+                        status='completed',
+                        collaboration_title=collaboration.title,
+                        collaboration_id=collaboration.id,
+                        user_type='creator'
+                    )
+
+                brand_user = User.query.get(collaboration.brand.user_id)
+                if brand_user:
+                    notify_collaboration_status(
+                        user_id=brand_user.id,
+                        status='completed',
+                        collaboration_title=collaboration.title,
+                        collaboration_id=collaboration.id,
+                        user_type='brand'
+                    )
+
+        db.session.commit()
+
+        # Notify creator about approval
+        creator_user = User.query.get(collaboration.creator.user_id)
+        if creator_user:
+            notify_collaboration_update(
+                user_id=creator_user.id,
+                collaboration_title=collaboration.title,
+                collaboration_id=collaboration.id,
+                update_message=f"Deliverable approved for {milestone.title}"
+            )
+
+        return jsonify({
+            'message': 'Deliverable approved successfully',
+            'deliverable': deliverable.to_dict(),
+            'milestone': milestone.to_dict(include_deliverables=True),
+            'collaboration': collaboration.to_dict(include_relations=True)
+        }), 200
+
+    except Exception as e:
+        db.session.rollback()
+        print(f"Error approving milestone deliverable: {str(e)}")
+        import traceback
+        traceback.print_exc()
+        return jsonify({'error': str(e)}), 500
+
+
+@bp.route('/<int:collab_id>/milestones/<int:milestone_id>/deliverables/<int:deliverable_id>/request-revision', methods=['POST'])
+@jwt_required()
+def request_milestone_deliverable_revision(collab_id, milestone_id, deliverable_id):
+    """Request revision on milestone deliverable (brand only)"""
+    try:
+        user_id = int(get_jwt_identity())
+        brand = BrandProfile.query.filter_by(user_id=user_id).first()
+
+        if not brand:
+            return jsonify({'error': 'Brand profile not found'}), 404
+
+        collaboration = Collaboration.query.get(collab_id)
+        if not collaboration:
+            return jsonify({'error': 'Collaboration not found'}), 404
+
+        if collaboration.brand_id != brand.id:
+            return jsonify({'error': 'Unauthorized'}), 403
+
+        milestone = CollaborationMilestone.query.get(milestone_id)
+        if not milestone or milestone.collaboration_id != collab_id:
+            return jsonify({'error': 'Milestone not found'}), 404
+
+        deliverable = MilestoneDeliverable.query.get(deliverable_id)
+        if not deliverable or deliverable.collaboration_milestone_id != milestone.id:
+            return jsonify({'error': 'Deliverable not found'}), 404
+
+        data = request.get_json()
+        revision_notes = data.get('notes', '')
+
+        if not revision_notes:
+            return jsonify({'error': 'Revision notes are required'}), 400
+
+        # Update deliverable
+        deliverable.status = 'revision_requested'
+        deliverable.revision_notes = revision_notes
+        deliverable.revision_requested_at = datetime.utcnow()
+
+        db.session.commit()
+
+        # Notify creator
+        creator_user = User.query.get(collaboration.creator.user_id)
+        if creator_user:
+            notify_collaboration_update(
+                user_id=creator_user.id,
+                collaboration_title=collaboration.title,
+                collaboration_id=collaboration.id,
+                update_message=f"Revision requested for deliverable in {milestone.title}"
+            )
+
+        return jsonify({
+            'message': 'Revision requested successfully',
+            'deliverable': deliverable.to_dict(),
+            'milestone': milestone.to_dict(include_deliverables=True)
+        }), 200
+
+    except Exception as e:
+        db.session.rollback()
+        print(f"Error requesting milestone deliverable revision: {str(e)}")
+        import traceback
+        traceback.print_exc()
+        return jsonify({'error': str(e)}), 500
+'''
diff --git a/backend/app/services/payment_service.py b/backend/app/services/payment_service.py
index 8b7bd9d..724fece 100644
--- a/backend/app/services/payment_service.py
+++ b/backend/app/services/payment_service.py
@@ -575,3 +575,76 @@ def process_payment_webhook(data):
     except Exception as e:
         print(f"Webhook processing error: {str(e)}")
         return False
+
+
+def release_milestone_escrow(milestone_id, platform_fee_percentage=15):
+    """
+    Release escrow for a specific completed milestone to creator wallet
+    Only releases the portion allocated to this milestone
+    """
+    from app.models import CollaborationMilestone, Collaboration, Transaction, WalletTransaction
+    from datetime import timedelta
+
+    milestone = CollaborationMilestone.query.get(milestone_id)
+    if not milestone:
+        raise ValueError(f"Milestone {milestone_id} not found")
+
+    if milestone.status != 'completed':
+        raise ValueError("Milestone must be completed before releasing escrow")
+
+    collaboration = Collaboration.query.get(milestone.collaboration_id)
+    if not collaboration:
+        raise ValueError(f"Collaboration not found for milestone {milestone_id}")
+
+    # Check if wallet transaction already exists for this milestone
+    existing_transaction = WalletTransaction.query.filter_by(
+        milestone_id=milestone_id,
+        transaction_type='milestone_earning'
+    ).first()
+
+    if existing_transaction:
+        raise ValueError("Funds already released for this milestone")
+
+    # Calculate amounts
+    milestone_amount = float(milestone.price)
+    platform_fee = milestone_amount * (platform_fee_percentage / 100)
+    creator_amount = milestone_amount - platform_fee
+
+    # Get or create wallet
+    wallet = get_or_create_wallet(collaboration.creator.user_id)
+
+    # Create wallet transaction with 30-day release countdown
+    transaction = WalletTransaction(
+        wallet_id=wallet.id,
+        user_id=collaboration.creator.user_id,
+        transaction_type='milestone_earning',
+        amount=creator_amount,
+        status='pending_clearance',
+        clearance_required=True,
+        clearance_days=30,
+        completed_at=datetime.utcnow(),
+        available_at=(datetime.utcnow() + timedelta(days=30)),
+        collaboration_id=collaboration.id,
+        milestone_id=milestone.id,
+        gross_amount=milestone_amount,
+        platform_fee=platform_fee,
+        platform_fee_percentage=platform_fee_percentage,
+        net_amount=creator_amount,
+        description=f"Milestone payment: {milestone.title}",
+        transaction_metadata={
+            'milestone_title': milestone.title,
+            'milestone_number': milestone.milestone_number,
+            'collaboration_title': collaboration.title,
+            'brand_name': collaboration.brand.company_name if collaboration.brand else 'Unknown'
+        }
+    )
+    db.session.add(transaction)
+
+    # Update wallet pending clearance
+    wallet.pending_clearance = float(wallet.pending_clearance or 0) + creator_amount
+    wallet.total_earned = float(wallet.total_earned or 0) + creator_amount
+    wallet.updated_at = datetime.utcnow()
+
+    db.session.commit()
+
+    return transaction
diff --git a/frontend/src/services/api.js b/frontend/src/services/api.js
index fda9143..b058105 100644
--- a/frontend/src/services/api.js
+++ b/frontend/src/services/api.js
@@ -210,13 +210,21 @@ export const collaborationsAPI = {
   getCollaboration: (id) => api.get(`/collaborations/${id}`),
   updateProgress: (id, data) => api.patch(`/collaborations/${id}/progress`, data),
 
-  // Deliverables
+  // Deliverables (for package-based collaborations)
   submitDeliverable: (id, data) => api.post(`/collaborations/${id}/deliverables`, data),
   submitDraftDeliverable: (id, data) => api.post(`/collaborations/${id}/deliverables/draft`, data),
   updateDraftDeliverable: (id, deliverableId, data) => api.put(`/collaborations/${id}/deliverables/${deliverableId}`, data),
   approveDeliverable: (id, deliverableId) => api.post(`/collaborations/${id}/deliverables/${deliverableId}/approve`),
   requestRevision: (id, deliverableId, notes) => api.post(`/collaborations/${id}/deliverables/${deliverableId}/request-revision`, { notes }),
 
+  // Milestone Deliverables (for brief/campaign collaborations)
+  submitMilestoneDeliverable: (collabId, milestoneId, data) =>
+    api.post(`/collaborations/${collabId}/milestones/${milestoneId}/deliverables`, data),
+  approveMilestoneDeliverable: (collabId, milestoneId, deliverableId) =>
+    api.post(`/collaborations/${collabId}/milestones/${milestoneId}/deliverables/${deliverableId}/approve`),
+  requestMilestoneRevision: (collabId, milestoneId, deliverableId, notes) =>
+    api.post(`/collaborations/${collabId}/milestones/${milestoneId}/deliverables/${deliverableId}/request-revision`, { notes }),
+
   // Paid Revision
   createRevisionBooking: (id, data) => api.post(`/collaborations/${id}/revision/create-booking`, data),
   completeRevisionPayment: (id, bookingId) => api.post(`/collaborations/${id}/revision/complete-payment`, { booking_id: bookingId }),
-- 
2.51.0.windows.1

